/**********************************************************************************************************************
 * \file uart.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/

#include "uart.h"
#include "shared_memory.h"
#include <string.h>
#include <stdio.h>
/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
/* Communication parameters */


/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
IfxAsclin_Asc *g_uartInstances[4] = {NULL};  // 0: Arduino, 1: RPi, 2: PC, 3: ToF

/* UART 모듈 객체 */
IfxAsclin_Asc g_uart_pc;      // ASCLIN3 -> pc debug
IfxAsclin_Asc g_uart_arduino; // ASCLIN0 -> arduino
IfxAsclin_Asc g_uart_rpi;     // ASCLIN1 -> raspberrypi
IfxAsclin_Asc g_uart_tof;     // ASCLIN2 -> tof

/* The transfer buffers allocate memory for the data itself and for FIFO runtime variables.
 * 8 more bytes have to be added to ensure a proper circular buffer handling independent from
 * the address to which the buffers have been located.
 */
volatile uint8 g_pcTxBuf[UART_BUFFER_SIZE + FIFO_OVERHEAD];
volatile uint8 g_pcRxBuf[UART_BUFFER_SIZE + FIFO_OVERHEAD];

volatile uint8 g_arduinoTxBuf[UART_BUFFER_SIZE + FIFO_OVERHEAD];
volatile uint8 g_arduinoRxBuf[UART_BUFFER_SIZE + FIFO_OVERHEAD];

volatile uint8 g_rpiTxBuf[UART_BUFFER_SIZE + FIFO_OVERHEAD];
volatile uint8 g_rpiRxBuf[UART_BUFFER_SIZE + FIFO_OVERHEAD];

volatile uint8 g_tofTxBuf[UART_BUFFER_SIZE + FIFO_OVERHEAD];
volatile uint8 g_tofRxBuf[UART_BUFFER_SIZE + FIFO_OVERHEAD];


/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/


void initUartChannel(IfxAsclin_Asc *asc,
                     IfxAsclin_Asc_Config *cfg,
                     const IfxAsclin_Asc_Pins *pins,
                     IfxAsclin_Asc *module,
                     uint8 *txBuf, uint8 *rxBuf,
                     int channelIndex)
{
    IfxAsclin_Asc_initModuleConfig(cfg, module);

    cfg->baudrate.baudrate = 115200;
    cfg->baudrate.oversampling = IfxAsclin_OversamplingFactor_16;
    cfg->bitTiming.medianFilter = IfxAsclin_SamplesPerBit_three;
    cfg->bitTiming.samplePointPosition = IfxAsclin_SamplePointPosition_8;

    cfg->interrupt.txPriority = 8 + channelIndex;
    cfg->interrupt.rxPriority = 4 + channelIndex;
    cfg->interrupt.erPriority = 12 + channelIndex;
    cfg->interrupt.typeOfService = IfxSrc_Tos_cpu1;

    cfg->pins = pins;

    cfg->txBuffer = txBuf;
    cfg->txBufferSize = UART_BUFFER_SIZE;
    cfg->rxBuffer = rxBuf;
    cfg->rxBufferSize = UART_BUFFER_SIZE;

    IfxAsclin_Asc_initModule(asc, cfg);

    g_uartInstances[channelIndex] = asc;
}

void init_uart_pc(void)
{
    IfxAsclin_Asc_Config cfg;
    static const IfxAsclin_Asc_Pins pins = {
        .rx = &IfxAsclin3_RXD_P32_2_IN,
        .rxMode = IfxPort_InputMode_pullUp,
        .tx = &IfxAsclin3_TX_P15_7_OUT,
        .txMode = IfxPort_OutputMode_pushPull,
        .cts = NULL_PTR,
        .ctsMode = IfxPort_InputMode_pullUp,
        .rts = NULL_PTR,
        .rtsMode = IfxPort_OutputMode_pushPull,
        .pinDriver = IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    initUartChannel(&g_uart_pc, &cfg, &pins, &MODULE_ASCLIN3, g_pcTxBuf, g_pcRxBuf, 2);  // index 2
}

void init_uart_arduino(void)
{
    IfxAsclin_Asc_Config cfg;
    static const IfxAsclin_Asc_Pins pins = {
        .rx = &IfxAsclin0_RXB_P15_3_IN,   // Arduino TX → MCU RX
        .rxMode = IfxPort_InputMode_pullUp,
        .tx = &IfxAsclin0_TX_P15_2_OUT,  // MCU TX → Arduino RX
        .txMode = IfxPort_OutputMode_pushPull,
        .cts = NULL_PTR,
        .ctsMode = IfxPort_InputMode_pullUp,
        .rts = NULL_PTR,
        .rtsMode = IfxPort_OutputMode_pushPull,
        .pinDriver = IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    initUartChannel(&g_uart_arduino, &cfg, &pins, &MODULE_ASCLIN0, g_arduinoTxBuf, g_arduinoRxBuf, 0); // index 0
}

void init_uart_rpi(void)
{
    IfxAsclin_Asc_Config cfg;
    static const IfxAsclin_Asc_Pins pins = {
        .rx = &IfxAsclin1_RXA_P15_1_IN,   // RPi TX → MCU RX
        .rxMode = IfxPort_InputMode_pullUp,
        .tx = &IfxAsclin1_TX_P15_0_OUT,  // MCU TX → RPi RX
        .txMode = IfxPort_OutputMode_pushPull,
        .cts = NULL_PTR,
        .ctsMode = IfxPort_InputMode_pullUp,
        .rts = NULL_PTR,
        .rtsMode = IfxPort_OutputMode_pushPull,
        .pinDriver = IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    initUartChannel(&g_uart_rpi, &cfg, &pins, &MODULE_ASCLIN1, g_rpiTxBuf, g_rpiRxBuf, 1); // index 1
}

void init_uart_tof(void)
{
    IfxAsclin_Asc_Config cfg;
    static const IfxAsclin_Asc_Pins pins = {
        .rx       = &IfxAsclin2_RXE_P33_8_IN,             // ToF TX → MCU RX
        .rxMode   = IfxPort_InputMode_pullUp,
        .tx       = &IfxAsclin2_TX_P33_9_OUT,             // MCU TX → ToF RX
        .txMode   = IfxPort_OutputMode_pushPull,
        .cts      = NULL_PTR,
        .ctsMode  = IfxPort_InputMode_pullUp,
        .rts      = NULL_PTR,
        .rtsMode  = IfxPort_OutputMode_pushPull,
        .pinDriver= IfxPort_PadDriver_cmosAutomotiveSpeed1
    };

    initUartChannel(
        &g_uart_tof,
        &cfg,
        &pins,
        &MODULE_ASCLIN2,
        g_tofTxBuf,
        g_tofRxBuf,
        3   // channel index: 0=Arduino, 1=RPi, 2=PC, 3=ToF
    );
}

/* all uart init */
void initUART(void)
{
    init_uart_pc();
    init_uart_arduino();
    init_uart_rpi();
    init_uart_tof();
}



